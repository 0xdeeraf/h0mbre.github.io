---
layout: single
title: CTP/OSCE -- SEH Based Overflow in Vulnserver GMON Parameter
date: 2019-5-25
classes: wide
header:
  teaser: /assets/images/CTP/immunity.jpg
tags:
  - buffer overflow
  - Windows
  - x86
  - shellcoding
  - exploit development
  - assembly
  - python
  - OSCE
  - CTP
  - SEH
--- 
![](/assets/images/CTP/1920x1080_Wallpaper.jpg)

## Introduction

This series of posts will focus on the concepts I'm learning/practicing in preparation for [CTP/OSCE](https://www.offensive-security.com/information-security-training/cracking-the-perimeter/). In this series of posts, I plan on exploring:
+ fuzzing,
+ vanilla EIP overwrite,
+ SEH overwrite, and
+ egghunters.

Writing these entries will force me to become intimately familiar with these topics, and hopefully you can get something out of them as well! 

In this particular post, we will become acquainted with an SEH-based overflow with the `GMON` command/parameter in Vulnserver. 

If you have not already done so, please read the first post of this series so that you can setup your environment, setup and use `boofuzz`, and become acquainted with some of the stack-based overflow concepts that are still relevant in this post. You can do so [here](https://h0mbre.github.io/Boofuzz_to_EIP_Overwrite/).

## What is an SEH-based Overflow? 

If you need some background information on what an SEH-based overflow entails, the [Corelan materials](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/) on the topic are great. 

Essentially what we need to know is that certain programs, when created, account for errors in execution by instituting error handlers which will allow a program to exit or stop gracefully when an error occurs. According to Corelan:

*"Windows has a default SEH (Structured Exception Handler) which will catch exceptions. If Windows catches an exception, you’ll see a “xxx has encountered a problem and needs to close” popup. This is often the result of the default handler kicking in.  It is obvious that, in order to write stable software, one should try to use development language specific exception handlers, and only rely on the windows default SEH as a last resort.   When using language EH’s, the necessary links and calls to the exception handling code are generate in accordance with the underlying OS.  (and when no exception handlers are used, or when the available exception handlers cannot process the exception, the Windows SEH will be used. (UnhandledExceptionFilter)).  So in the event an error or illegal instruction occurs, the application will get a chance to catch the exception and do something with it. If no exception handler is defined in the application, the OS takes over, catches the exception, shows the popup (asking you to Send Error Report to MS)."*

We can visualize how these SEH 'record/handler' components exist on the stack, culminating with the Microsoft OS level exception handler at `0xFFFFFF`, with Corelan's visual aids: 

![](/assets/images/CTP/stackview.png)

![](/assets/images/CTP/exTEB.png)

To get a better understanding of `TEB` and `FS:[0]`, let us again consult the outstanding Corelan materials: 

*"At the top of the main data block (the data block of the application’s “main” function, or TEB (Thread Environment Block) / TIB (Thread Information Block)), a pointer to the top of the SEH chain is placed. This SEH chain is often called the FS:[0] chain as well.
So, on Intel machines, when looking at the disassembled SEH code, you will see an instruction to move DWORD ptr from FS:[0]. This ensures that the exception handler is set up for the thread and will be able to catch errors when they occur.  The opcode for this instruction is 64A100000000. If you cannot find this opcode, the application/thread may not have exception handling at all...\<snip\>
...The bottom of the SEH chain is indicated by FFFFFFFF. This will trigger an improper termination of the program (and the OS handler will kick in)"*

The values and memory addresses in the second visual aid come from compiling and debugging the following C source code: 
```c
#include
#include<string.h>
#include

int ExceptionHandler(void);
int main(int argc,char *argv[]){

char temp[512];

printf("Application launched");

 __try {

    strcpy(temp,argv[1]);

    } __except ( ExceptionHandler() ){
}
return 0;
}
int ExceptionHandler(void){
printf("Exception");
return 0;
}
```

The last bit of information we will pluck from the Corelan materials is the following:

*"In other words, the payload must do the following things:*
+ *cause an exception. Without an exception, the SEH handler (the one you have overwritten/control) won’t kick in*
+ *overwrite the pointer to the next SEH record with some jumpcode (so it can jump to the shellcode)*
+ *overwrite the SE handler with a pointer to an instruction that will bring you back to next SEH and execute the jumpcode.*
+ *The shellcode should be directly after the overwritten SE Handler. Some small jumpcode contained in the overwritten 'pointer to next SEH record' will jump to it)."*

![](/assets/images/CTP/pprdemo.png)

I've tried to capture the crucial points from the Corelan material, but it's difficult without just copy/pasting the entire web page. Please do yourself a favor and read the post in its entirety if you are new to SEH-based exploits. 

Now that we have some level of understanding of how SEH's reside on the stack, their sub-components, their occupation of memory-space, and what our exploit should accomplish at a high-level, we can begin fuzzing Vulnserver for an opportunity to develop an SEH-based overflow. 

## Boofuzzing `GMON`

In a real life scenario, we would be fuzzing all of the commands offered by Vulnserver, but to save some time I've narrowed our search for an SEH-based exploit to the `GMON` parameter. Let's start by first getting ac
