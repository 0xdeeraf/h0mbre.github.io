---
layout: single
title: CTP/OSCE -- SEH Based Overflow in Vulnserver GMON Parameter
date: 2019-5-25
classes: wide
header:
  teaser: /assets/images/CTP/immunity.jpg
tags:
  - buffer overflow
  - Windows
  - x86
  - shellcoding
  - exploit development
  - assembly
  - python
  - OSCE
  - CTP
  - SEH
--- 
![](/assets/images/CTP/1920x1080_Wallpaper.jpg)

## Introduction

This series of posts will focus on the concepts I'm learning/practicing in preparation for [CTP/OSCE](https://www.offensive-security.com/information-security-training/cracking-the-perimeter/). In this series of posts, I plan on exploring:
+ fuzzing,
+ vanilla EIP overwrite,
+ SEH overwrite, and
+ egghunters.

Writing these entries will force me to become intimately familiar with these topics, and hopefully you can get something out of them as well! 

In this particular post, we will become acquainted with an SEH-based overflow with the `GMON` command/parameter in Vulnserver. 

If you have not already done so, please read the first post of this series so that you can setup your environment, setup and use `boofuzz`, and become acquainted with some of the stack-based overflow concepts that are still relevant in this post. You can do so [here](https://h0mbre.github.io/Boofuzz_to_EIP_Overwrite/).

**This post will assume the reader is already familiar with how to attach processes in Immunity, use boofuzz, search for bad characters, and other knowledge domains covered in the first post of the series.**

## What is an SEH-based Overflow? 

If you need some background information on what an SEH-based overflow entails, the [Corelan materials](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/) on the topic are great. 

Essentially what we need to know is that certain programs, when created, account for errors in execution by instituting error handlers which will allow a program to exit or stop gracefully when an error occurs. According to Corelan:

*"Windows has a default SEH (Structured Exception Handler) which will catch exceptions. If Windows catches an exception, you’ll see a “xxx has encountered a problem and needs to close” popup. This is often the result of the default handler kicking in.  It is obvious that, in order to write stable software, one should try to use development language specific exception handlers, and only rely on the windows default SEH as a last resort.   When using language EH’s, the necessary links and calls to the exception handling code are generate in accordance with the underlying OS.  (and when no exception handlers are used, or when the available exception handlers cannot process the exception, the Windows SEH will be used. (UnhandledExceptionFilter)).  So in the event an error or illegal instruction occurs, the application will get a chance to catch the exception and do something with it. If no exception handler is defined in the application, the OS takes over, catches the exception, shows the popup (asking you to Send Error Report to MS)."*

We can visualize how these SEH 'record/handler' components exist on the stack, culminating with the Microsoft OS level exception handler at `0xFFFFFF`, with Corelan's visual aids: 

![](/assets/images/CTP/stackview.png)

![](/assets/images/CTP/exTEB.png)

To get a better understanding of `TEB` and `FS:[0]`, let us again consult the outstanding Corelan materials: 

*"At the top of the main data block (the data block of the application’s “main” function, or TEB (Thread Environment Block) / TIB (Thread Information Block)), a pointer to the top of the SEH chain is placed. This SEH chain is often called the FS:[0] chain as well.
So, on Intel machines, when looking at the disassembled SEH code, you will see an instruction to move DWORD ptr from FS:[0]. This ensures that the exception handler is set up for the thread and will be able to catch errors when they occur.  The opcode for this instruction is 64A100000000. If you cannot find this opcode, the application/thread may not have exception handling at all...\<snip\>
...The bottom of the SEH chain is indicated by FFFFFFFF. This will trigger an improper termination of the program (and the OS handler will kick in)"*

The values and memory addresses in the second visual aid come from compiling and debugging the following C source code: 
```c
#include
#include<string.h>
#include

int ExceptionHandler(void);
int main(int argc,char *argv[]){

char temp[512];

printf("Application launched");

 __try {

    strcpy(temp,argv[1]);

    } __except ( ExceptionHandler() ){
}
return 0;
}
int ExceptionHandler(void){
printf("Exception");
return 0;
}
```

The last bit of information we will pluck from the Corelan materials is the following:

*"In other words, the payload must do the following things:*
+ *cause an exception. Without an exception, the SEH handler (the one you have overwritten/control) won’t kick in*
+ *overwrite the pointer to the next SEH record with some jumpcode (so it can jump to the shellcode)*
+ *overwrite the SE handler with a pointer to an instruction that will bring you back to next SEH and execute the jumpcode.*
+ *The shellcode should be directly after the overwritten SE Handler. Some small jumpcode contained in the overwritten 'pointer to next SEH record' will jump to it)."*

*"A typical payload will look like this*

*\[Junk\]\[nSEH\]\[SEH\]\[Nop-Shellcode\]*

*Where nSEH = the jump to the shellcode, and SEH is a reference to a pop pop ret*

*Make sure to pick a universal address for overwriting the SEH. Ideally, try to find a good sequence in one of the dll’s from the application itself."*

![](/assets/images/CTP/pprdemo.png)

I've tried to capture the crucial points from the Corelan material, but it's difficult without just copy/pasting the entire web page. Please do yourself a favor and read the post in its entirety if you are new to SEH-based exploits. 

Now that we have some level of understanding of how SEH's reside on the stack, their sub-components, their occupation of memory-space, and what our exploit should accomplish at a high-level, we can begin fuzzing Vulnserver for an opportunity to develop an SEH-based overflow. 

## Boofuzzing `GMON`

In a real life scenario, we would be fuzzing all of the commands offered by Vulnserver, but to save some time I've narrowed our search for an SEH-based exploit to the `GMON` parameter. Fortunately, our `boofuzz` script won't have to change much from the our script in the first post of the series. We can use the following script:
```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.1.201'	#windows VM
port = 9999		#vulnserver port

def main():
	
	session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')))
	
	s_initialize("GMON")	#just giving our session a name, "GMON"

    	s_string("GMON", fuzzable = False)	#these strings are fuzzable by default, so here instead of blank, we specify 'false'
    	s_delim(" ", fuzzable = False)		#we don't want to fuzz the space between "GMON" and our arg
   	s_string("FUZZ")			#This value is arbitrary as we did not specify 'False' for fuzzable. Boofuzz will fuzz this string now
 
        session.connect(s_get("GMON"))		#having our 'session' variable connect following the guidelines we established in "GMON"
    	session.fuzz()				#calling this function actually performs the fuzzing

if __name__ == "__main__":
    main()
```

Sending our `boofuzz` script to Vulnserver nets us this in Immunity: 

![](/assets/images/CTP/imm.JPG)

Pay special attention to the `use Shift+F7/F8/F9 to pass exception to program` message at the bottom of the screen. We see that `ECX` and `EBP` have been overwritten with `B` chars. This seems to align with the 3rd fuzzing payload sent with `boofuzz` when we look through our command line output on our remote attacker. We can see the following in our command line:
```terminal_session
[2019-05-25 19:30:13,689] Test Case: 3: GMON.no-name.3
[2019-05-25 19:30:13,689]     Info: Type: String. Default value: 'FUZZ'. Case 3 of 1441 overall.
[2019-05-25 19:30:13,689]     Info: Opening target connection (192.168.1.201:9999)...
[2019-05-25 19:30:13,690]     Info: Connection opened.
[2019-05-25 19:30:13,691]   Test Step: Fuzzing Node 'GMON'
[2019-05-25 19:30:13,691]     Info: Sending 5012 bytes...
[2019-05-25 19:30:13,691]     Transmitted 5012 bytes: 47 4d 4f 4e 20 2f 2e 2e 2e 2f 42 42 42 42 42 42 42 42 42 42 42 42...<snip>...00 00 'GMON /.../BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB...<snip>...BBBBBBBBB\x00\x00
```

Let's use `F9` to pass an exception to the program.

![](/assets/images/CTP/F9.JPG)


