---
layout: single
title: CTP/OSCE Prep -- 'LTER' SEH Based Overflow in Vulnserver
date: 2019-5-29
classes: wide
header:
  teaser: /assets/images/CTP/immunity.jpg
tags:
  - buffer overflow
  - Windows
  - x86
  - shellcoding
  - exploit development
  - assembly
  - python
  - OSCE
  - CTP
  - SEH
--- 
![](/assets/images/CTP/1920x1080_Wallpaper.jpg)

## Introduction

This series of posts will focus on the concepts I'm learning/practicing in preparation for [CTP/OSCE](https://www.offensive-security.com/information-security-training/cracking-the-perimeter/). In this series of posts, I plan on exploring:
+ fuzzing,
+ vanilla EIP overwrite,
+ SEH overwrite, and
+ egghunters.

Writing these entries will force me to become intimately familiar with these topics, and hopefully you can get something out of them as well! 

In this particular post, we will be approaching an overflow in the `LTER` parameter trying to utilize all the tricks we've learned thus far. 

If you have not already done so, please read some of the posts in the 'CTP/OSCE Prep' series as this post will be light on review! 

## Goals

For this post, our goal is to try to utilize all the skills we've gained thus far to exploit Vulnserver in a new way, finding a new vulnerable parameter.

## Fuzzing

I tried to go sequentially through the parameters and find one I could fuzz which would make the application crash but none of the first few parameters would actually crash the server. I then picked some at random and struck out there as well. After this excercise, I'm going to have to go back and check people's walkthroughs and see if there is a problem with my Fuzzing methodology and I'm missing vulnerable params. Finally, I fuzzed `LTER` and got the server to crash. Loading it up in Immunity it looked to be an SEH overwrite, we've prepared for this!

The final `boofuzz` script I used looked like this:
```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.1.201'	#windows VM
port = 9999		#vulnserver port

def main():
	
	session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')))
	
	s_initialize("LTER")	#just giving our session a name, "LTER"

    	s_string("LTER", fuzzable = False)	#these strings are fuzzable by default, so here instead of blank, we specify 'false'
    	s_delim(" ", fuzzable = False)		#we don't want to fuzz the space between "LTER" and our arg
   	s_string("FUZZ")			#This value is arbitrary as we did not specify 'False' for fuzzable. Boofuzz will fuzz this string now
 
        session.connect(s_get("LTER"))		#having our 'session' variable connect following the guidelines we established in "LTER"
    	session.fuzz()				#calling this function actually performs the fuzzing

if __name__ == "__main__":
    main()
```

## The Crash!

![](/assets/images/CTP/LTERcrash.JPG)

The first things I noted in Immunity when the server crashed:
+ We are being prompted by Immunity to pass an exception to the program,
+ We have overwritten ECX and EBP, 
+ The stack shows us that `01B4F1F0` and `01B4F1F4` hold `"LTER /.../BBBB..."`

Where do we go from here? Well, we know that having control of the registers is great; however, since we're going to have to pass an exception to this program, and we don't have control of EIP, these registers will be `XOR` against themselves and zeroed out. So the registers are dead to us. 

We definitely want to use the feedback we got from the stack readout where we saw `"LTER /.../BBBB..."`, we will hardcode this into our exploit script. 

The next step we want to do is track down exactly how many bytes `boofuzz` sent and since we know we filled the registers with `B` values, it shouldn't be too hard to track down the exact payload the fuzzer sent. 

## Replicating the Crash





## Big Thanks

To everyone who has published free intro-level 32 bit exploit dev material, I'm super appreciative. Truly mean it. 
